---
title: Управление соотношением элементов вдоль главной оси
slug: >-
  Web/CSS/CSS_flexible_box_layout/Controlling_ratios_of_flex_items_along_the_main_axis
translation_of: >-
  Web/CSS/CSS_Flexible_Box_Layout/Controlling_Ratios_of_Flex_Items_Along_the_Main_Ax
original_slug: >-
  Web/CSS/CSS_Flexible_Box_Layout/Controlling_Ratios_of_Flex_Items_Along_the_Main_Ax
---

{{CSSRef}}В данном руководстве, мы исследуем три свойства применяемые к flex элементам, которые позволяют нам контролировать размер и гибкость flex элементов по основной(main) оси. Полное понимание, как эти свойства работают, при увеличение и уменьшение элементов, есть ключ к мастерству flexbox.

## Первый взгляд

Наши три свойства определяют следующие аспекты гибкости flex-элемента:

- `flex-grow`: Сколько положительного свободного места занимает этот элемент?
- `flex-shrink`: Сколько отрицательного свободного места можно удалить из этого элемента?
- `flex-basis`: Каков размер элемента до того, как произойдет его увеличение или сжатие?

Свойства обычно выражаются в виде сокращенного свойства {{Cssref("flex")}}. Следующий код установит свойству `flex-grow` значение `2`, `flex-shrink` значение `1` и `flex-basis` значение `auto`.

```css
.item {
  flex: 2 1 auto;
}
```

Если вы читали статью [Основные концепции Flexbox](/ru/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox), то у вас уже есть представление об этих свойствах. Здесь мы подробно рассмотрим их, чтобы вы могли полностью понять, что делает браузер, когда вы их используете.

## Важные понятия при работе на главной оси

Есть несколько концепций, с которыми стоит ознакомиться, прежде чем рассматривать, как свойства flex работают для управления соотношениями вдоль главной оси. Они относятся к _естественному_ размеру гибких изделий до того, как произойдет какое-либо увеличение или сжатие, а также к концепции свободного пространства. 

### Определение размера flex-элемента

Чтобы определить, сколько места доступно для размещения flex-элемента, браузеру необходимо знать, какого размера элемент изначально. Как это работает для элементов, которые не имеют ширины или высоты, заданных с помощью единицы абсолютной длины?

В CSS есть концепция {{CSSxRef('width','min-content','#min-content')}} и {{CSSxRef('width','max-content','#max-content')}} - эти ключевые слова [определены в спецификации внутренних и внешних размеров CSS](https://drafts.csswg.org/css-sizing-3/#width-height-keywords ) и может использоваться вместо [единицы измерения длины](/ru/docs/Web/CSS/length). 

Например, в приведенном ниже примере у меня есть два элемента абзаца, которые содержат строку текста. Первый абзац имеет ширину `min-content`. В браузере, поддерживающем это ключевое слово, вы должны увидеть, что текст использовал все доступные ему возможности мягкого переноса (soft wrapping), став настолько маленьким, насколько это возможно, без переполнения. Таким образом, это размер `min-content` этой строки. По сути, самое длинное слово в строке определяет размер.

Второй абзац имеет значение `max-content`, и поэтому он делает обратное. Он становится настолько большим, насколько это возможно, не используя возможности мягкого переноса (soft wrapping). Он переполнил бы контейнер, в котором находится, если бы этот контейнер был слишком узким. 

{{EmbedGHLiveSample("css-examples/flexbox/ratios/min-max-content.html", '100%', 750)}}

Если ваш браузер еще не поддерживает эти ключевые слова, оба абзаца будут отображаться как обычные абзацы в block flow; на приведенных ниже скриншотах показан ожидаемый рендеринг.

![Первый абзац сворачивается до самого длинного слова, второй растягивается так, чтобы вызвать переполнение.](ratios-size.png)

Запомните это поведение и то, какие эффекты оказывают `min-content` и `max-content`, когда мы рассмотрим `flex-grow` и `flex-shrink` позже в этой статье. 

### Положительное и отрицательное свободное пространство

Чтобы говорить об этих свойствах, нам нужно понять концепцию **положительного и отрицательного свободного пространства**. Когда во flex-контейнере имеется достаточное количество свободного места, в нем больше места, чем требуется для отображения адуч-элементов внутри контейнера. Например, если у меня есть контейнер шириной 500 пикселей, {{CSSxRef("flex-direction")}} - `row`, и у меня есть три гибких элемента шириной по 100 пикселей, тогда у меня есть 200 пикселей положительного свободного пространства, которое можно было бы распределить между элементами, если бы я хотел, чтобы они наполнили контейнер. 

![Изображение, показывающее пространство, оставшееся после отображения элементов.](basics7.png)

У нас есть отрицательное свободное пространство, когда естественный размер элементов в сумме превышает доступное пространство вo flex-контейнере. Если у меня есть контейнер шириной 500 пикселей, подобный приведенному выше, но три flex-элемента имеют ширину по 200 пикселей каждый, то общее пространство, которое мне нужно, составит 600 пикселей, так что у меня есть 100 пикселей отрицательного свободного пространства. Его можно было бы убрать с элементов, чтобы они поместились в контейнер. 

![Элементы переполняют контейнер](ratios1.png)

Именно это распределение положительного свободного пространства и удаление отрицательного свободного пространства нам нужно понять, чтобы понять свойства flex.

В следующих примерах я работаю с {{CSSxRef("flex-direction")}}, установленным в row, поэтому размер элементов всегда будет зависеть от их ширины. Мы будем вычислять положительное и отрицательное свободное пространство, созданное путем сравнения общей ширины всех элементов с шириной контейнера. Вы могли бы в равной степени исследовать каждый пример с помощью `flex-direction: column`. Тогда главной осью будет столбец, и вам нужно будет сравнить высоту элементов и высоту контейнера, в котором они находятся, чтобы определить положительное и отрицательное свободное пространство. 

## Свойство flex-basis

Свойство {{CSSxRef("flex-basis")}} определяет начальный размер flex-элемента до того, как произойдет какое-либо распределение пространства. Начальное значение для этого свойства - `auto`. Если для свойства `flex-basis` установлено значение `auto`, то для определения начального размера элемента браузер сначала проверяет, установлен ли основного размера элемента в абсолютных единицах. Это было бы в том случае, если бы вы присвоили своему элементу ширину 200 пикселей. В этом случае "200 пикселей" было бы `flex-basis` для этого элемента.

Если вместо этого размер вашего элемента задан автоматически, то значение `auto` будет соответствовать размеру его содержимого. На этом этапе ваши знания о размерах `min-` и `max-content` становятся полезными, поскольку flexbox будет использовать размер элемента `max-content` в качестве `flex-basis`. Следующий пример может помочь продемонстрировать это.

В этом примере я создал серию негибких блоков, для которых как `flex-grow` так и `flex-shrink` установлено значение `0`. Здесь мы можем видеть, как первый элемент, у которого в качестве основного размера задана явная ширина в 150 пикселей, свойство `flex-basis` принимает значение `150px`, в то время как два других элемента не имеют ширины и поэтому имеют размер в соответствии с шириной их содержимого.

{{EmbedGHLiveSample("css-examples/flexbox/ratios/flex-basis.html", '100%', 500)}}

В дополнение к ключевому слову `auto` вы можете использовать ключевое слово `content` в качестве значений `flex-basis`. Это приведет к тому, что значение `flex-basis` будет взято из размера содержимого, даже если для элемента задана ширина. Это более новое ключевое слово, и оно имеет меньшую поддержку браузером, однако вы всегда можете получить тот же эффект, используя `auto` в качестве flex-basis и убедившись, что у вашего элемента не задана ширина, чтобы он автоматически изменял размер.

Если вы хотите, чтобы flexbox полностью игнорировал размер элемента при распределении пространства, тогда установите для `flex-basis` значение `0`. По сути, это говорит flexbox о том, что все пространство доступно для захвата, и о необходимости распределять его пропорционально. Мы увидим примеры этого, когда перейдем к рассмотрению `flex-grow`.

## Свойство flex-grow

Свойство {{CSSxRef("flex-grow")}} определяет **коэффициент flex grow**, который определяет, насколько flex-элемент будет увеличиваться относительно остальных flex-элементов во flex-контейнере при распределении положительного свободного пространства.

Если все элементы имеют одинаковый коэффициент `flex-grow`, то пространство будет распределено между ними равномерно. Если это та ситуация, которая вам нужна, то обычно вы бы использовали `1` в качестве значения, однако вы могли бы задать им всем `flex-grow` в размере `88`, или `100`, или `1,2`, если хотите - это соотношение. Если коэффициент одинаков для всех, и во flex-контейнере есть положительное свободное пространство, то оно будет распределено поровну между всеми.

### Сочетание `flex-grow` и `flex-basis`

Взаимодействие `flex-grow` и `flex-basis` может показаться сбивающим с толку. Давайте рассмотрим случай с тремя flex-элементами с содержимым разной длины и следующие `flex` правила, применяемые к ним:

`flex: 1 1 auto;`

В этом случае значение `flex-basis` равно `auto`, и элементы не имеют заданной ширины, поэтому их размер определяется автоматически. Это означает, что flexbox смотрит на размер элементов `max-content`. После раскладывания элементов у нас остается некоторое количество свободного пространства в гибком контейнере, показанное на этом изображении в виде заштрихованной области:

![Изображения показывают положительное свободное пространство в виде заштрихованной области](ratios2.png)

Мы работаем с `flex-basis`, равной размеру содержимого, поэтому доступное пространство для распределения вычитается из общего доступного пространства (ширина гибкого контейнера), а оставшееся пространство затем распределяется поровну между каждым элементом. Наш более крупный элемент в конечном итоге становится больше, потому что он начинался с большего размера, даже несмотря на то, что ему отведено столько же свободного места, сколько и остальным:

![Положительное пространство распределяется между элементами](ratios3.png)

Если то, что вам нужно, - это три элемента одинакового размера, даже если им изначально заданы разные размеры, вам следует использовать это:

`flex: 1 1 0;`

Здесь мы говорим, что размер элемента для расчета распределения пространства равен `0` — все пространство доступно для захвата, и поскольку все элементы имеют одинаковый коэффициент `flex-grow`, каждому из них распределяется равный объем пространства. Конечным результатом являются три гибких элемента одинаковой ширины.

Попробуйте изменить коэффициент `flex-grow` с 1 на 0 в этом примере, чтобы увидеть разницу в поведении:

{{EmbedGHLiveSample("css-examples/flexbox/ratios/flex-grow.html", '100%', 520)}}

### Назначение элементам различных значений flex-grow

Наше понимание того, как `flex-grow` работает с `flex-basis`, позволяет нам дополнительно контролировать индивидуальные размеры наших элементов, назначая им различные коэффициенты `flex-grow`. Если мы сохраним свойство `flex-basis` со значением `0`, чтобы можно было распределить все пространство, мы могли бы присвоить каждому из трех flex-элементов разный коэффициент `flex-grow`. В приведенном ниже примере я использую следующие значения:

- `1` для первого элемента.
- `1` для второго элемента.
- `2` для третьего элемента.

Работая с `flex-basis` со значением `0`, мы распределяем доступное пространство следующим образом. Нам нужно сложить коэффициенты flex grow, затем разделить общее количество положительного свободного пространства во flex-контейнере на это число, которое в данном случае равно 4. Затем мы распределяем пространство в соответствии с индивидуальными значениями — первому элементу достается одна часть, второму - одна часть, третьему - две части. Это означает, что третий элемент в два раза больше первого и второго элементов.

{{EmbedGHLiveSample("css-examples/flexbox/ratios/flex-grow-ratios.html", '100%', 520)}}

Помните, что здесь вы можете использовать любое положительное значение. Важно соотношение между одним элементом и другими. Вы можете использовать большие числа или десятичные дроби — это зависит от вас. Чтобы проверить это, измените значения, присвоенные в приведенном выше примере, на `.25`, `.25` и `.50` — вы должны увидеть тот же результат.

## Свойство `flex-shrink`

Свойство {{CSSxRef("flex-shrink")}} определяет **коэффициент flex shrink**, который определяет, насколько flex-элемент уменьшится относительно остальных flex-элементов во flex-контейнере при распределении отрицательного свободного пространства.

Это свойство относится к ситуациям, когда браузер вычисляет значения `flex-basis` flex-элементов и обнаруживает, что они слишком велики, чтобы поместиться во flex-контейнер. Пока `flex-shrink` имеет положительное значение, элементы будут сжиматься, чтобы они не переполняли контейнер.

Таким образом, там, где `flex-grow` занимается добавлением свободного пространства,  `flex-shrink` управляет освобождением места, чтобы блоки помещались в контейнер без переполнения.

В следующем примере у меня есть три элемента во flex-контейнере; я присвоил каждому ширину 200 пикселей, а ширина контейнера составляет 500 пикселей. Если для параметра `flex-shrink` установлено значение `0`, элементы не могут сжиматься, и поэтому они переполняют контейнер.

{{EmbedGHLiveSample("css-examples/flexbox/ratios/flex-shrink.html", '100%', 500)}}

Измените значение `flex-shrink` на `1`, и вы увидите, что каждый элемент уменьшился на одинаковую величину, чтобы все элементы теперь поместились в контейнер. Для этого они стали меньше своей первоначальной ширины.

### Сочетание `flex-shrink` и `flex-basis`

Вы могли бы сказать, что `flex-shrink` работает практически так же, как `flex-grow`. Однако есть две причины, по которым это не _совсем_ одно и то же.

Хотя обычно это незаметно, определение в спецификации является одной из причин, по которой `flex-shrink` не совсем то же самое для отрицательного пространства, что `flex-grow` для положительного пространства:

> "Примечание: Коэффициент flex shrink умножается на размер flex base при распределении отрицательного пространства. Это распределяет отрицательное пространство пропорционально тому, насколько элемент способен уменьшаться, так что, например, маленький элемент не уменьшится до нуля до того, как будет заметно уменьшен более крупный элемент."

Вторая причина заключается в том, что flexbox предотвращает сжатие мелких элементов до нулевого размера во время такого удаления отрицательного свободного пространства. Элементы будут сжаты в соответствии с их `min-content` - размером, который они приобретут, если воспользуются любыми доступными им возможностями мягкого переноса (soft wrapping).

Вы можете видеть, как это происходит с `min-content` в приведенном ниже примере, где `flex-basis` изменяется в соответствии с размером содержимого. Если вы измените ширину flex-контейнера — увеличив ее, например, до 700 пикселей — а затем уменьшите ширину flex-элемента, вы можете увидеть, что первые два элемента будут перенесены, однако они никогда не станут меньше размера `min-content`. По мере того, как контейнер становится меньше, пространство просто удаляется из третьего элемента.

{{EmbedGHLiveSample("css-examples/flexbox/ratios/flex-shrink-min-content.html", '100%', 500)}}

На практике поведение при сжатии, как правило, дает вам разумные результаты. Обычно вы не хотите, чтобы ваш контент полностью исчезал или чтобы блоки становились меньше, чем их минимальное содержимое, поэтому приведенные выше правила имеют смысл с точки зрения разумного поведения для контента, который необходимо уменьшить, чтобы он поместился в контейнер.

### Назначение элементам различных значений `flex-shrink`

Точно так же, как с `flex-grow`, вы можете присвоить flex-элементам различные коэффициенты `flex-shrink`. Это может помочь изменить поведение по умолчанию, если, например, вы хотите, чтобы элемент сжимался более или менее быстро, чем его собратья, или не сжимался вообще.

В следующем примере первый элемент имеет коэффициент `flex-shrink`, равный 1, второй - `0` (так что он вообще не будет сжиматься), а третий - `4`. Таким образом, третий элемент сжимается быстрее, чем первый. Поиграйте с различными значениями — что касается `flex-grow`, то здесь вы можете использовать десятичные дроби или большие числа. Выбирайте то, что имеет для вас наибольший смысл.

{{EmbedGHLiveSample("css-examples/flexbox/ratios/flex-shrink-ratios.html", '100%', 570)}}

## Освоение определения размеров flex-элементов

Ключом к настоящему пониманию того, как работает настройка размеров flex-элементов, является понимание ряда факторов, которые начинают действовать. Рассмотрим следующие аспекты, которые мы уже обсуждали в этих руководствах:

### Что определяет базовый размер элемента?

1. Установлено ли значение `flex-basis` на `auto`, и задана ли ширина элемента? Если это так, то размер будет зависеть от этой ширины. 
2. Установлено ли значение `flex-basis` на `auto` или `content` (в поддерживающем браузере)? Если это так, то размер зависит от размера элемента. 
3. Является ли значение свойства`flex-basis` единицей длины, но не нулем? Если это так, то это размер элемента.
4. Установлено ли значение `flex-basis` на `0`? Если это так, то размер элемента не учитывается при расчете распределения пространства.

### Есть ли у нас свободное место?

Элементы не могут увеличиваться при отсутствии положительного свободного пространства, и они не будут уменьшаться, если нет отрицательного свободного пространства.

1. Если мы возьмем все элементы и сложим их ширину (или высоту, если работаем в столбце), будет ли это общее количество **меньше**, чем общая ширина (или высота) контейнера? Если это так, то у вас есть положительное свободное пространство, и в игру вступает свойство `flex-grow`. 
2. Если мы возьмем все элементы и сложим их ширину (или высоту, если работаем в столбце), будет ли это общее количество **больше**, чем общая ширина (или высота) контейнера? Если это так, то у вас отрицательное свободное пространство, и в игру вступает свойство `flex-shrink`. 

### Другие способы распределения пространства

Если вы не хотите, чтобы к элементам добавлялось свободное пространство, помните, что вы можете использовать свободное пространство между элементами или вокруг них, используя свойства выравнивания, описанные в руководстве по выравниванию элементов во flex-контейнере. Свойство {{CSSxRef("justify-content")}} позволит распределять свободное пространство между элементами или вокруг них. Вы также можете использовать свойство margin со значением auto для flex-элементов, чтобы уменьшить пространство и создать промежутки(gap) между элементами.

Имея в своем распоряжении все инструменты flex, вы обнаружите, что большинство задач выполнимы, хотя поначалу может потребоваться немного поэкспериментировать.
