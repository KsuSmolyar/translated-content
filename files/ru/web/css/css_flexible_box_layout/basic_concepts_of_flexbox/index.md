---
title: Основные понятия Flexbox
slug: Web/CSS/CSS_flexible_box_layout/Basic_concepts_of_flexbox
translation_of: Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox
---

{{CSSRef}}

**CSS модуль раскладки Flexible Box**, обычно называемый флексбокс или flexbox или просто flex (флекс), был разработан как модель одномерного-направленного макета и как один из методов распределения пространства между элементами в интерфейсе, с мощными возможностями выравнивания. В этой статье даётся краткое описание основных функций flexbox, которые мы рассмотрим более подробно в остальных руководствах.

Когда мы описываем flexbox как одномерно-направленный, мы имеем в виду, что flexbox имеет дело с макетом в одной плоскости за раз – либо в виде строки, либо в виде столбца. Как альтернативу можно упомянуть двумерную модель CSS Grid Layout, которая управляет и столбцами и строками одновременно.

## Flexbox: две оси

При работе с flexbox нужно мыслить с точки зрения двух осей – главной оси и побочной оси. Главная ось определяется свойством {{cssxref ("flex-direction")}}, а побочная ось проходит перпендикулярно ей. Все, что мы делаем с flexbox, относится к этим осям, поэтому стоит с самого начала понять, как они работают.

### Главная ось

Главная ось определяется свойством `flex-direction`, которая может принимать одно из следующих значений:

- `row`
- `row-reverse`
- `column`
- `column-reverse`

Если вы выберете `row` или `row-reverse`, ваша главная ось будет проходить в горизонтальном направлении **(inline direction)**.

![If flex-direction is set to row the main axis runs along the row in the inline direction.](basics1.png)

Если вы выберете `column` или `column-reverse`, ваша главная ось будет проходить в вертикальном направлении **(block direction)**.

![If flex-direction is set to column the main axis runs in the block direction.](basics2.png)

### Побочная ось

Побочная ось проходит перпендикулярно главной оси, поэтому, если свойство `flex-direction` (главная ось) задано как `row` или `row-reverse`, побочная ось будет проходить в вертикальном направлении.

![If flex-direction is set to row then the cross axis runs in the block direction.](basics3.png)

Если свойство `flex-direction` задано как `column` или `column-reverse`, побочная ось будет проходить в горизонтальном направлении.

![If flex-direction is set to column then the cross axis runs in the inline direction.](basics4.png)

Понимание того, с какой осью вы работаете (главная или побочная) очень важно для дальнейшего изучения Flexbox.

## Начало и конец строки

Важно понимать, что flexbox не делает никаких предположений о режиме написания документа. Раньше CSS был сильно ориентирован на горизонтальный режим и режим письма слева направо. Современные методы вёрстки охватывают полный диапазон режимов письма, и поэтому мы больше не предполагаем, что строка текста будет начинаться в верхнем левом углу документа и будет проходить по направлению к правой стороне, а новые строки будут появляться одна под другой.

Вы можете прочитать больше о взаимосвязи между flexbox и спецификацией Writing Modes в следующей статье, однако следующее описание должно помочь объяснить, почему мы не говорим о левом, правом, верхнем и нижнем направлениях наших flex-элементов.

Если свойству `flex-direction` задано значение `row` и вы работаете с английским языком, то начало главной оси будет слева, а конец главной оси – справа.

![Working in English the start edge is on the left.](basics5.png)

Если бы вы работаете с арабским языком, то начало главной оси будет справа, а конец главной оси – слева.

![The start edge in a RTL language is on the right.](basics6.png)

В обоих случаях начало побочной оси находится вверху flex контейнера, а конец – внизу, поскольку оба языка имеют режим горизонтальной записи.

Спустя некоторое время становится естественным думать о начале и конце оси, а не о левом и правом краях. Это будет полезно для вас при работе с другими методами, такими как CSS Grid Layout, которые следуют тем же шаблонам.

## Flex контейнер

Область документа, использующая flexbox, называется flex контейнером. Чтобы создать flex контейнер, мы задаём значение `flex` или `inline-flex` для свойства {{cssxref ("display")}} контейнера. Как только мы делаем это, прямые потомки этого контейнера становятся flex элементами. Как и для всех свойств в CSS, некоторые начальные значения уже определены, поэтому при создании flex-контейнера все содержащиеся в нем flex-элементы будут вести себя следующим образом.

- Элементы отображаются в ряд (свойство `flex-direction` по умолчанию имеет значение `row`).
- Позиционирование элементов начинается от начала главной оси.
- Элементы не растягиваются по основной оси, но могут сжиматься.
- Элементы будут растягиваться, чтобы заполнить размер побочной оси.
- Свойству {{cssxref("flex-basis")}} задано значение `auto`.
- Свойству {{cssxref("flex-wrap")}} задано значение `nowrap`.

Результатом этого является то, что все ваши элементы будут выстроены в ряд, используя размер содержимого в качестве их размера на главной оси. Если в контейнере больше элементов, чем можно уместить, они не будут обёрнуты и контейнер будет переполнен. Если некоторые элементы выше других, все элементы будут вытянуты вдоль побочной оси, чтобы заполнить ось в полный размер.

Вы можете увидеть принцип работы в живом примере ниже. Попробуйте отредактировать или добавить дополнительные элементы, чтобы проверить поведение flexbox.

{{EmbedGHLiveSample("css-examples/flexbox/basics/the-flex-container.html", '100%', 480)}}

### Изменение flex-direction

Добавление свойства {{cssxref ("flex-direction")}} в контейнер позволяет нам изменять направление, в котором отображаются наши элементы flex. Установка `flex-direction: row-reverse` сохранит порядок отображения элементов вдоль строки, однако начало и конец строки поменяются местами.

Если изменить значение свойства `flex-direction` на `column`, главная ось изменится, и наши элементы будут отображаются в столбец. При установке параметра `column-reverse`, начало и конец столбца поменяются местами.

В приведённом ниже примере значение свойства `flex-direction` установлено как `row-reverse`. Попробуйте другие значения — `row`, `column` и `column-reverse`, чтобы посмотреть как изменятся элементы контейнера.

{{EmbedGHLiveSample("css-examples/flexbox/basics/flex-direction.html", '100%', 350)}}

## Многострочный флекс-контейнер с flex-wrap

Несмотря на то, что флекс-бокс - это однонаправленная модель, есть возможность завернуть наши флекс-элементы в несколько строк. При этом вы должны рассматривать каждую строку как новый флекс контейнер. Распределение пространства будет происходить на этой конкретной линии, не привязываясь к соседним линиям.

Чтобы включить такое поведение, добавьте параметр {{cssxref("flex-wrap")}} со значением `wrap`. Теперь, как только ваши элементы будут слишком большими для того, чтобы влезать на одну строчку, они будут переноситься на новые строки. Живой пример ниже содержит широкие элементы, у которых общая ширина больше, чем размер контейнера. Так как параметр `flex-wrap` установлен в значение `wrap`, элементы переносятся. Если вы установите значение `nowrap`, то есть в начальное значение, то элементы ужмутся так, чтобы все элементы поместились на одной строке, потому что у них установлено значение, позволяющее им ужиматься при необходимости. Если им запретить ужиматься, или если они не смогут ужаться достаточно сильно, то при установленном значении `nowrap` будет происходить переполнение контейнера.

{{EmbedGHLiveSample("css-examples/flexbox/basics/flex-wrap.html", '100%', 400)}}

Более подробно эту тема разбирается в статье [Разбираемся с обёртыванием Flex элементов](/ru/docs/Web/CSS/CSS_Flexible_Box_Layout/Mastering_Wrapping_of_Flex_Items).

## Краткая запись направления и многострочности: flex-flow

Вы можете указать два свойства `flex-direction` и `flex-wrap` в одном {{cssxref("flex-flow")}}. Первое значение свойства определяет `flex-direction`, второе `flex-wrap`.

В приведённом ниже примере вы можете изменить первое значение на одно из доступных для `flex-direction` - `row`, `row-reverse`, `column` or `column-reverse`, а второе на `wrap` или `nowrap`, чтобы посмотреть как изменятся элементы контейнера.

{{EmbedGHLiveSample("css-examples/flexbox/basics/flex-flow.html", '100%', 400)}}

## Свойства, применяемые к флекс-элементам

Управлять поведением флекс-элементов более детально мы можем с помощью их собственных свойств:

- {{cssxref("flex-grow")}}
- {{cssxref("flex-shrink")}}
- {{cssxref("flex-basis")}}

В этом обзоре мы лишь кратко рассмотрим эти свойства. Чтобы получить более глубокое понимание обратитесь к руководству [Управление соотношением элементов вдоль главной оси](/ru/docs/Web/CSS/CSS_Flexible_Box_Layout/%D0%9A%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D1%81%D0%BE%D0%BE%D1%82%D0%BD%D0%BE%D1%88%D0%B5%D0%BD%D0%B8%D1%8F_%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2_%D0%B2%D0%B4%D0%BE%D0%BB%D1%8C_%D0%B3%D0%BB%D0%B0%D0%B2%D0%BD%D0%BE%D0%B9_%D0%BE%D1%81%D0%B8).

Чтобы понять как работают эти свойства, прежде нам необходимо разобраться с концепцией **доступного пространства**. Изменяя значения этих флекс свойств, мы влияем на то, как доступное пространство распределяется между нашими элементами. Эта концепция так же важна для выравнивания элементов.

Если наш контейнер шириной 500 пикселей содержит три элемента шириной 100 пикселей каждый, для их размещения нам потребуется пространство шириной в 300 пикселей. Остаётся 200 пикселей свободного пространства. Если мы не изменим исходные значения этих свойств, флексбокс разместит это пространство за последним элементом.

![This flex container has available space after laying out the items.](basics7.png)

Если вместо этого мы хотим чтобы элементы росли и заполняли собой свободное пространство, нам нужно указать способ распределения оставшегося пространства между элементами. Это как раз то для чего предназначены `flex` свойства.

### Свойство `flex-basis`

Свойство `flex-basis` определяет размер доступного пространства элемента. Начальное значение этого свойства - `auto` - в этом случае браузер проверяет, имеют ли элементы размер. В приведённом выше примере все элементы имеют ширину 100px, и этот размер читается браузером как `flex-basis`.
Если элементы не имеют размера, то для размера `flex-basis` используется размер контента. Вот почему, когда мы просто объявляем `display: flex` на родительском элементе для создания flex-элементов, все элементы перемещаются в ряд и занимают столько места, сколько им нужно для отображения их содержимого.

### Свойство `flex-grow`

Если для свойства`flex-grow` задано положительное целое число, flex-элементы могут расти вдоль главной оси от их `flex-basis`. Это приведет к тому, что элемент растянется и займет все доступное пространство на этой оси или часть доступного пространства, если другим элементам также разрешено расти.

Если бы мы присвоили всем элементам в приведенном выше примере значение `flex-grow`, равное 1, тогда доступное пространство во flex-контейнере было бы поровну разделено между нашими элементами, и они бы растянулись, чтобы заполнить контейнер по главной оси.

Свойство flex-grow можно использовать для пропорционального распределения пространства. Если мы присвоим нашему первому элементу значение `flex-grow`, равное 2, а другим элементам значение, равное 1, то 2 части будут отданы первому элементу (100рх из 200рх в случае приведенного выше примера), и по 1 части каждому из двух остальных (по 50рх каждому из общих 200рх).

### Свойство `flex-shrink`

Если свойство `flex-grow` связано с добавлением пространства на главной оси,то свойство `flex-shrink` управляет тем, как оно удаляется. Если у нас недостаточно места в контейнере для размещения наших элементов, а для `flex-shrink` задано положительное целое число, элемент может стать меньше, чем его `flex-basis`. Как и в случае с `flex-grow`, могут быть назначены разные значения, чтобы заставить один элемент сжиматься быстрее, чем другие - элемент с более высоким значением, установленным для `flex-shrink`, будет сжиматься быстрее, чем его братья и сестры с более низкими значениями.

Минимальный размер элемента будет учитываться при расчете фактической величины усадки(`shrinkage`), которая произойдет, а это означает, что flex-shrink может показаться менее последовательным в поведении, чем flex-grow. Поэтому мы более подробно рассмотрим, как работает этот алгоритм, в статье [Управление соотношением элементов вдоль главной оси](/ru/docs/Web/CSS/CSS_Flexible_Box_Layout/%D0%9A%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D1%81%D0%BE%D0%BE%D1%82%D0%BD%D0%BE%D1%88%D0%B5%D0%BD%D0%B8%D1%8F_%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2_%D0%B2%D0%B4%D0%BE%D0%BB%D1%8C_%D0%B3%D0%BB%D0%B0%D0%B2%D0%BD%D0%BE%D0%B9_%D0%BE%D1%81%D0%B8).

> **Примечание:** Обратите внимание, что значения для `flex-grow` и `flex-shrink` являются пропорциями. Как правило, если бы мы установили для всех наших элементов значение flex: `1 1 200px`, а затем захотели, чтобы один элемент рос в два раза быстрее, мы бы установили для этого элемента значение flex: `2 1 200px`. Однако вы можете использовать flex: `10 1 200px` и flex: `20 1 200px`, если хотите.

### Краткая запись значений флекс свойств

Вы очень редко увидите свойства `flex-grow`, `flex-shrink` и `flex-basis`, используемые по отдельности; вместо этого они объединяются в короткую запись {{cssxref("flex")}}. Короткая запись `flex` позволяет вам установить три значения в таком порядке — `flex-grow`, `flex-shrink`, `flex-basis`. 

Живой пример ниже позволяет вам протестировать различные значения сокращенной записи flex; помните, что первое значение — `flex-grow`. Присвоение этому свойству положительного значения означает, что элемент может расти. Второй — `flex-shrink` — при положительном значении элементы могут сжиматься, но только если их суммарные значения выходят за переделы главной оси. Последнее значение — `flex-basis`; это значение, которое элементы используют в качестве своего базового значения для увеличения и уменьшения.

{{EmbedGHLiveSample("css-examples/flexbox/basics/flex-properties.html", '100%', 510)}}

Есть также некоторые предварительно заданные сокращённые значения, которые охватывают большинство вариантов использования. Вы часто будете видеть, как они используются в учебных пособиях, и во многих случаях это все, что вам нужно будет использовать. Предварительно заданные значения следующие:

- `flex: initial`
- `flex: auto`
- `flex: none`
- `flex: <positive-number>`

Установка `flex: initial` сбрасывает элемент к начальным значениям Flexbox. Это то же самое, что `flex: 0 1 auto`. В этом случае значение `flex-grow` равно 0, поэтому элементы не будут увеличиваться больше, чем их размер `flex-basis`. Значение `flex-shrink` равно 1, поэтому элементы могут сжиматься, если им нужно, вместо того, чтоб переполнять контейнер. Значение `flex-basis` равно `auto`. Элементы либо будут использовать любой размер, который установлен для элемента в основном измерении, либо они получат свой размер в зависомости от размера содержимого. 

Использование `flex: auto` аналогично использованию `flex: 1 1 auto`; все как с `flex:initial`, но в этом случае элементы могут увеличиваться и заполнять контейнер, а также уменьшаться при необходимости.

Использование `flex: none` создаст полностью негибкие flex-элементы. Это как если бы вы написали `flex: 0 0 auto`. Элементы не могут увеличиваться или уменьшаться, но будут размещены с использованием flexbox с `flex-basis`, равным `auto`.

Короткая запись, которую вы часто видите в учебных пособиях, это `flex: 1` или `flex: 2` и т.д. Это как если бы вы использовали `flex: 1 1 0`. Элементы могут увеличиваться и уменьшаться, начиная с `flex-basis`, равного 0.

Попробуйте эти значения для сокращенной записи в живом примере ниже.

{{EmbedGHLiveSample("css-examples/flexbox/basics/flex-shorthands.html", '100%', 510)}}

## Выравнивание и распределение свободного пространства между элементами

Ключевой особенностью flexbox является возможность выравнивать элементы по главной и поперечной осям, а также распределять пространство между flex-элементами.

### `align-items`

Свойство {{cssxref("align-items")}} будет выравнивать элементы по поперечной оси.

Начальное значение этого свойства — `stretch`, и именно поэтому flex-элементы по умолчанию растягиваются до высоты самого высокого из них. На самом деле они растягиваются, чтобы заполнить flex-контейнер — самый высокий элемент определяет его высоту. 

Вместо этого вы можете установить для свойтва `align-items` значение `flex-start`, чтобы элементы выстроились в начале flex-контейнера, `flex-end`, чтобы выстроить их в конец flex-контейнера, или `center`, чтобы выровнять их по центру. Протестируйте это в примере ниже — flex-контейнеру задана высота, чтобы вы могли видеть, как элементы можно перемещать внутри контейнера. Посмотрите, что произойдет, если вы установите следующие значения для свойства align-items: 

- `stretch`
- `flex-start`
- `flex-end`
- `center`

{{EmbedGHLiveSample("css-examples/flexbox/basics/align-items.html", '100%', 520)}}

### `justify-content`

Свойство {{cssxref("justify-content")}} используется для выравнивания элементов по главной оси, направление, которое установлено в свойстве `flex-direction`. Начальное значение `flex-start`, которое выстроит элементы в линию в начале контейнера, но вы также можете установить значение `flex-end`, чтобы выровнять их в конце, или `center`, чтобы выровнять их по центру.

Вы также можете использовать значение `space-between`, чтобы занять все свободное пространство после того, как элементы были расположены, и равномерно распределить его между элементами, так чтобы между каждым элементом было равное пространство. Чтобы распределить одинаковое количество пространства справа и слева от каждого элемента, используйте значение `space-around`. Со значением `space-around` элементы имеют пространство половинного размера с обоих концов. Или, чтобы элементы имели одинаковое пространство вокруг себя, используйте значение `space-evenly`. Со значением `space-evenly` элементы имеют полноразмерное пространство с обоих концов.

Попробуйте следующие значения `justify-content` в примере:

- `flex-start`
- `flex-end`
- `center`
- `space-around`
- `space-between`
- `space-evenly`

{{EmbedGHLiveSample("css-examples/flexbox/basics/justify-content.html", '100%', 380)}}

В статье [Aligning Items in a Flex Container](/ru/docs/Web/CSS/CSS_Flexible_Box_Layout/Aligning_Items_in_a_Flex_Container) мы рассмотрим эти свойства более подробно, чтобы лучше понять, как они работают. Однако эти простые примеры будут полезны в большинстве случаев.

## Next steps

Прочитав эту статью, вы должны иметь представление об основных возможностях Flexbox. В следующей статье мы рассмотрим [как эта спецификация связана с другими частями CSS](/ru/docs/Web/CSS/CSS_Flexible_Box_Layout/Relationship_of_Flexbox_to_Other_Layout_Methods).
